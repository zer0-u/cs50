# week7 SQL

## 0306

### 講義動画
- TV番組の名前とジャンルのアンケートを取ったらしい
  - ジャンルは複数選べる
  - ジャンルは1つの列にカンマ区切りで収められている
- 結果を使っていろいろな分析をしてみたい
- スプレッドシートが得意なこと
  - 検索やソートが素早い
  - 大量のデータを保存できる(限度はある)
- スプレッドシートは行と列でデータを保存する
- データを追加する時は行が増える
- 列は属性やフィールド(保存するデータの種類)を表す
  - フォームやシートを作る時に考えるべきこと
  - 列はあまり増えない
- データのレイアウトやスキーマ(構造)は事前に決めておくのが一般的
- CSVファイルはフラットファイルデータベースと呼ばれる
- データベース＝データを保存するファイルやプログラムのこと
- カンマの代わりに違う区切り文字を使っても良い
- データの中にカンマがあると混乱を起こしやすい
  - 含めたい時はデータをダブルクォートで挟むとよい
  - 区切り文字としてのカンマとそうでないものを分ける
- フラットファイルデータベースでは数式を扱えない
- 回答結果をCSVとしてダウンロードしてCS50 IDEにアップロードする
- Pythonを使って分析してみる(favorites.py)
  - 実行はできないが一応実装してみる
- やりたいことは小さく分けて実装する
- open関数の第2引数(モード)のデフォルト値はr(読み込み)
  - →読み込みの場合は第2引数がなくても動く
- DictReaderはpythonに組み込まれたもの
  - 最初の行をカンマで分割し、それぞれの値が列名だと「仮定」している
  - 1行目にヘッダがないとうまく動作しない
- タイトルの重複をなくしたい
- 方法1：setを使う
  - addメソッドで追加
  - forループで取り出し(setはイテレータを保持している)
- setの中身をソートする
  - sorted関数に渡せば自動的にソートしてくれる
- 表記ゆれまではカバーできない
  - 大文字・小文字を揃える＝正規化(なんらかのルールに従って標準化すること)
  - upper()メソッドを呼び出す
- 多少はまとまったがまだ重複している
  - 末尾のスペースの有無が差を生んでいるっぽい
  - stripメソッドで取り除く(先頭と末尾の空白文字を削除)
- これ以上の正規化はとても手間がかかる
  - typoの検知・修正など
  - これが現実
- 今日はここまで(30:55)

## 0308

### 講義動画
- 一昨日見ていたものと違う気がする
- 6日は2020版・8日は2021版
  - 困ったことになった
  - 新しいものの方がいいだろうし改めて2021版を見ることにした
  - 冒頭は倍速で
  - 6日に実装したものは2020フォルダへ移動した
- この回のポイントはデータの永続化
  - プログラムが終了してもデータを残す方法
- CSVとエクセルの違い
  - テキストファイルだが規則を持っている
  - フラットファイルデータベース
  - CSVは完全にポータブル
- 一番人気のある番組を調べたい
- DictReaderは単純なreaderより堅牢性が高い
- 重複のフィルタリング
- ますはlistを用いる
  - favorites0.py
- 入力値から不要な空白を取り除く
- すべて大文字に変換する
- pythonはメソッドチェーンが書けるので便利
- 結構違う流れなので結局等速で見ている
- データの外見を標準化＝正規化している
- python2を使っているらしい？
- listをsetに置き換える(favorites2.py)
  - setの省略記法的なものはないのかな
  - {}だった
- sortedでタイトル一覧をソートする
- これ以上の正規化はとてもむずかしい
- タイトルを入力した人数を数える
  - ここで実装していない差分については無視する
  - 「Brooklyn-99」と「Brooklyn 99」とか
- dictを使ってタイトル(title)と回数(count)を紐づけたい
  - favorites3.py
- dictとsetは省略記法が同じ{}
  - 中身の書き方で差別化するらしい
- titles[title]+=1で数を記録する？
- 実行するとエラーが発生する
  - KeyError(存在しない要素を参照しようとしている)
- 回数を増やす前に存在チェックを挟む
  - 存在すれば1増やす、しなければ0と紐づける
- dictをforで回すとキー名しか参照されない
  - print(title, titles[title]) で回数も表示される
- 存在チェックでfalseだった場合は0ではなく1で初期化すべきだった
  - あるいは0で初期化し、1増やす処理を常に行う
  - どちらの方法でも良い
  - 重要なのは事前にチェックすること
- dictのソート(sorted(dictオブジェクト))はキーによって行われる
- 値(登場回数)でソートしたい
- sorted関数には複数の引数を渡せる
  - 例 reverse=Trueで逆順
- 値でソートしたい時はソート用の関数を用意する
  - get_value関数
- sorted関数のkey引数にキー(を取得する関数そのもの)を渡す
- reverse=Trueは数値だと大きい順を意味する
- THE OFFICEってどんな番組なんだろう
- favorites3.pyをもっと短くしたい
- 引数keyにget_value関数ではなくラムダ関数を渡す
  - lambda 引数:戻り値
  - 再利用しないと分かっている関数を用意したい時に便利
- ラムダは1行だけの関数に使う
  - 基本的にすぐreturnされるとみなす(returnは書かない)
  - 難しい処理も盛り込めるが推奨されない
- 今回はここまで(36:14)

## 0309

### 講義動画(36:15)
- 1つのタイトルに注目する(favorites4.py)
- 「The Office」のつもりで「Office」と投稿した人がいたらもちろん総数は減る
  - 両方カウントするにはどうしたらいいか
- orで条件を複雑にする
- "OFFICE" in title ともできる
  - title(文字列)に「OFFICE」が含まれたら
- 「thevoffice」があることが分かった
- 「THE OFFICE」と「OFFICE」が同じものってどうして分かるんだろう？
  - テレビ番組はよくわからない
- 正規表現
- Googleフォームは回答の検証ができる
  - 検証に正規表現も使える
  - メールアドレスを表す正規表現は「.+@.+\..+」
- pythonでも正規表現が使える
  - reライブラリをimportする
  - re.search(パターン,対象文字列)
- re.search("office", title)にしたら何も検出されなかった
  - ひとまず大文字にしなければならない
- 「^(OFFICE|THE OFFICE)$」
  - OFFICEまたはTHE OFFICEで始まり、それ以外の内容がない
- 「^(OFFICE|THE.OFFICE)$」
  - THEの後に任意の1文字を指定できる
- THE OFFICE以外の番組名にも対応させる(favorites5.py)
  - 調べたいタイトルを最初に入力してもらう

### 講義動画(48:17)
- 生のコードを書くよりも効率的にデータを保持・操作したい
- この後SQLを紹介するらしい
  - ツールを使うことのトレードオフも紹介するらしい
- リレーショナルデータベース
  - スプレッドシートそのものに近い
  - CSVはスプレッドシートの中の1つのシートに相当する
- なんかVSCodeの調子が悪いのでMarkdownの拡張機能を一旦無効にした
- データを上手く処理するためのツールや言語が必要
- CRUDの話
- CREATE TABLE
- favorites.csvをリレーショナルデータベースに変換するには
  - .move csv
  - .import FILE TABLE
  - SQLなら↑2つでいいらしい
- この講座だとSQLは「シークェル」読み
- SQLite3を使う
- sqlite3 favorites.db で新しいデータベースを作る
  - 拡張子.dbは慣習的なもの
  - 自分の手元では確認プロンプトが出たが動画では出ていない
- .mode csvでCSVモードに切り替えた後、.import favorites.csv favorites.dbでインポートする
- .schemaでスキーマ構造を参照できる
- 今回はimportを使ったので、sqliteがよしなにしてくれる
  - テーブル作成(列名や型はファイルから推測)
  - データ追加
- プロンプトの終わり方が分からない
  - .exit だった
  - https://so-zou.jp/web-app/tech/database/sqlite/sqlite-command/
- CSVファイルがないので一旦見るだけにする
- SELECT文
- 組み込み関数
  - distinct(title)で重複を排除する
- 途中で空白行があるのが気になる
  - 誰かがタイトルに空白文字を投稿した？
- distinct(upper(title))で大文字小文字の差を無視して重複を排除できる
- count(title)で投稿されたタイトルの総数が分かる
- WHEREやGROUP BYで行をフィルタリングする
- LIKEでパターンマッチングを行う
  - title like "%office%"
  - SQLがサポートする正規表現はちょっと控えめなので細かいことをやりたい場合はPythonを使う
- LIMITで表示件数を制限する
- DELETE文
- UPDATE文
- データを簡単に変更できるのがリレーショナルデータベースの強み
- 今日はここまで(1:08:06)

## 0310
- Markdownプラグインを有効化した

### 講義動画(1:08:06)
- データベースの設計
- SQLの予約語は大文字、列名やテーブル名は小文字で表している
  - 慣習的なもの
- 現在のfavoritesテーブルのgenresを見る
- UPDATEのデモの時にWHEREを指定しそびれて全部が同じ結果になってしまった
  - 取り消せないのでfavorites.dbを消して作り直す
- comedyを選択した作品を出してみる
  - WHERE genres = "Comedy" だとComedy「だけ」を指定した作品が出てくる
  - 複数ジャンルの中にComedyが含まれるものは検出できない
  - LIKEを使うとComedyを含む作品がすべて表示される
- LIKEを使うと「Music」と「Musical」が区別できない
  - MusicにMusicalが含まれてしまう
- カンマ区切りで1つのセルに複数の値を入れるのは単純だが参照しづらい
- Pythonのコードを使ってデータを加工する
  - showsテーブルとgenresテーブルに分ける
- バージョン8？
  - オンラインで公開されているらしい
  - どこにあるか分からない
- CS50ライブラリに含まれるSQL操作関数を呼び出している
- favorites.csvを読み込み、1行ごとに処理をする
  - 最終的にshowsテーブルとgenresテーブルができる
- showsテーブル
  - id列(整数・プライマリキー)
  - title列(文字列・NOT NULL)
- genresテーブル
  - show_id(整数・外部キー)
  - genre(文字列・NOT NULL)
- この時点ではタイトルを正規化していない
  - 同じタイトルが複数出てくる
- 1行1データなのでスッキリ見える
- 同じshow_idを持つ行が複数ある
  - ジャンルを複数選んだ場合
- 1対多の関係
  - 1つの番組に対して複数のジャンルを持っていること
- genresテーブルを使えば「Comedy」にチェックを入れた番組が簡単に抽出できる
- select title from shows where id in (select show_id from genres where genre = "Comedy");
- distinctをつければ重複も排除できる
- SQLは徐々に作っていく方がよい
- DBをCSVに転送する方法はいくつかある
  - SQLiteには書き出しコマンドがある
  - 基本的にはSQLの世界でデータを長期的に保存する
- データを増やす場合はshowsテーブルとgenresテーブルの両方に追加する必要がある
  - 場合によってはgenresテーブルに複数の行を追加する
- これらの作業はいずれpythonやSQLを使って全て自動化される予定
- 今日はここまで(1:31:38)

## 0313

### 講義動画(1:31:40)
- pythonでやっていたあれこれをSQLに置き換えてみる(favorites6.py)
- cs50ライブラリのSQL関数を使う
  - ほかはわりと複雑
- 今アクセスするのはfavoritesテーブル
  - showsとgenresはまだもう少し先の話
- LIKE ?でプレースホルダが成立するらしい
  - %ほげほげ%って感じになるんだろうか？
  - ならないっぽい(1:36:10頃のデモ)
- LIKEによる検索は大文字小文字のゆらぎを無視してくれるらしい
  - 「LIKE "The Office"」で「ThE OffiCE」が引っかかる

### 講義動画(1:40:00)
- データセットを大きくする
- IMDbの実際のデータセットから作ったRDB
  - InternetMovieDatabase.com
  - https://www.imdb.com/
  - テレビ番組や映画・俳優などを検索できるウェブサイト
  - データセットはTSV(タブ区切り)で提供される
- データセットの中身を確かめる
  - 今回の講義は基本的に見ているだけなのかな？
- shows, genres, stars, writers, ratingsなどのテーブルが見える
- shows
  - id・タイトル・年・総エピソード数
- SQLiteで扱うデータ型は全部で5つ
  - integer(整数)
  - numeric(日付や時間のための、整数や実数でない数値)
  - real(実数)
  - text(字数制限のないテキスト)
  - blob(binary large object)

## 0314
- 昨日はなんか変なところで終わらせてしまった

### 講義動画(1:42:45)
- showsテーブルの詳細
  - idは自動的に挿入された整数(プライマリキー)
- genresテーブルはshowsテーブルへの外部キーを持っている
- stars(出演者)
  - show_id, person_id
- writers(脚本家)
  - show_id, person_id
- rating(評価？)
  - show_id
  - rating(評価の★の数？・実数)
  - votes(投票数)
- people(人物)
  - writersとstarsの親
  - 氏名と生まれ年を持つ
  - peopleとpersonてニュアンス的にはどう違うんだろう
- 共通点を取り出して1つのテーブルに定義している
- peopleテーブルには100万人以上のデータが保存されている
- SQLの実行時間をはかる
  - .timer onの後にSQL文を実行すると、実行結果の後に所要時間が表示される
- titleが"The Office"のshows一覧は0.02秒ほどで取得できた
- showsテーブルのtitle列にインデックスを張ってみる
  - 作成に0.349秒かかる
  - インデックス作成後のSELECT文は計測できないほど短時間で実行できた
- データ構造(week5)と実行時間(week3)にも関わってくる
- インデックスなしの場合は上から順番に参照していく
- インデックスを張ると、DBへ事前にヒントを与えられる
  - 線形探索ではなくツリー構造が使えるようになる
- RDBの世界ではB-treeをよく使う
  - 二分木ではない
  - 高さ控えめ・子が3つ以上あるときもある木構造
- テーブルを結合する
- Steve Callelが出演する番組を全て知りたい
  - showsとpeopleをつなぐ必要がある
  - starsテーブルは結合テーブル(2テーブルをつなぐもの)
- まずはpeopleでIDを取得する
  - 名前と生年は気にしなくて良い
- starsテーブルを使うと、あるperson_idに紐付けられたshow_idをすべて取得できる
- SELECT title FROM shows WHERE id IN (SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Steve Carell"));
- 長くなるので要素に分解して考える
- order by titleをつけるとタイトルのアルファベット順で参照できる
- 0.094秒で結果が出た
  - スピードアップできないか？
  - starsテーブルのperson_id列・show_id列にもインデックスを張る
  - それぞれ作成に0.89秒・0,64秒かかった
  - peopleテーブルのname列にもインデックスを張る
  - 0.84秒で作成
  - 0.001秒まで短縮できた
- データセットが遅い時は適切なインデックスが存在しない場合が多い
  - プログラムが採用したアルゴリズムが悪い可能性もある
- ネストされた＝括弧で括られたクエリが多くなってきた
- JOINで短縮しよう
  - SELECT title FROM people JOIN stars ON people.id = stars.person_id;
  - id列を使ってpeopleテーブルとstarsテーブルを結合する
  - SELECT title FROM people JOIN stars ON people.id = stars.person_id JOIN shows ON stars.show_id = shows.id
  - showsテーブルも結合する
  - SELECT title FROM people JOIN stars ON people.id = stars.person_id JOIN shows ON stars.show_id = shows.id WHERE name = "Steve Carell";
  - 検索対象を指定する
  - 1つのクエリで同じ結果が得られるようになった
- SELECT title FROM people, stars, shows WHERE people.id = stars.person_id AND stars.show_id = shows.id AND name = "Steve Carell";
  - 同じ結果を得るためのSQL文は複数ある
  - 必要なテーブルを列挙してWHEREで絞る
  - セミコロンをつけなければ文中での改行も可
- インデックスのデメリット
  - インデックスが増えるほどメモリが必要になる
  - ちょうどいい数を見つけるのも設計プロセスの一部
- 今日はここまで(2:03:40)

## 0316
codespacesがアップデートしたのでプラグインを入れ直した

### 講義動画(2:03:40)
- SQLインジェクションの話
- 大きな力には大きな責任が伴う
- cs50ライブラリのexecute関数はプレースホルダをサポートしている
- 文字列結合でSQL文を組み立てるとインジェクションの恐れがある
- ユーザ名に '存在するユーザ'--' とするだけでパスワードを入力せずにログインできてしまう
- updateやdropも実行できてしまう

### 講義動画(2:11:40)
- 競合状態(race conditions)
- 複数のユーザが同時に同じデータを参照しようとする時の問題
  - SQLやpythonに限らずコンピュータ全般で発生する
- Instagramの投稿に「いいね！」を押すと何が起きるか
  - SELECT文で対象の投稿の「いいね！」数を取得する(IDで特定)
  - 「いいね！」数を1増やす(Python)
  - UPDATE文で「いいね！」数を更新する
- 複数のユーザが同時に「いいね！」を押すと何がおきるか
  - ↑の処理はアトミックではない
  - 上から順に実行されるが、間に別のユーザの処理が割り込んでくるかもしれない
  - 正しい結果が得られなくなる
- 正しく実行するにはそれぞれの処理をアトミックにする必要がある
  - 他のユーザの処理を割り込ませないようにする
- 「ロック」という解決策があることを知っておいて欲しい
  - トランザクションの概念
- 講義動画おわり！

## 0317

### lab
- 既存のテーブルはsongsとartistsの2つ

CREATE TABLE songs (
    id INTEGER,
    name TEXT,
    artist_id INTEGER,
    danceability REAL,
    energy REAL,
    key INTEGER,
    loudness REAL,
    speechiness REAL,
    valence REAL,
    tempo REAL,
    duration_ms INTEGER
);
CREATE TABLE artists (
    id INTEGER,
    name TEXT
);