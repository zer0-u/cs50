# week5 data structures

## 0118

- Codespaceそのものをアップデートすると自前で入れたプラグインが削除されてしまう
  - markdown all in oneを入れ直した

### mallocとrealloc
- C言語は今回で最後らしい
- 検索ではなく挿入コストの話
  - ソート済のサイズnの配列に要素を1つ挿入するには何ステップかかるか
  - O(n)・Ω(1)
- list[3]とmalloc()はメモリが確保される領域が違う
  - listはスタック
  - mallocはヒープ
  - このあたり覚えてないから復習しなければ
  - week4のnote見たら動画だった……
- list[3]だと永遠にサイズ3の配列を与えることになる
- list=tmpとする *前に* list(が指しているメモリの塊)を解放する必要がある
- コメントで書いた方が流れがわかりやすいかもしれない
- reallocは↓3つを行う
  - 新たなメモリの確保
  - 以前のメモリにあった内容を新たな領域にコピー
  - 以前のメモリを解放
- reallocの戻り値をもとの変数に代入することはできないんだろうか
  - 試してみたらできた(list_3_1.c)

### struct
- ドット演算子は構造の中のフィールドにアクセスする
- *は掛け算だったりポインタだったり間接参照だったりする
- structとドットと*があれば大抵のデータ構造は網羅できるらしい
- 糖衣構文「->」を使うとプロパティにアクセスして代入された値を見れる(. *と同義)
- 連結リスト(linked list)の話をしている
  - ポインタのための容量(8バイト)と引き換えにデータのコピーを免れる
  - 要素を作る時に、要素そのものを収める空間とは別にポインタを収める空間も要求する
- 連結リストの最後の要素はポインタとして何を持つべきか
  - 先頭の要素は無限ループを引き起こすので推奨できない
  - NULL(0x0)を入れる
- 循環を検出できれば＝先頭が判別できれば先頭の要素へのポインタも入れられる
- 今日はここまで

## 0119

### 36:00頃～
- mallocは有効なメモリを記録している
- コンパイラも有効/無効を区別する補助ができる
- 整数は4バイト、ポインタは8バイト
  - 単なる配列よりメモリは必要になる
  - コピー頻度とのトレードオフ

### ノード
- 連結リストの要素1つをノード(NODE)と呼ぶことにする
- structとtypedefを使ってノードを表現する
- フィールドは2つ
  - 要素そのもの(int number)
  - 次のノードへのポインタ(node *next)
  - nextは慣習的な名前
- node型の定義の中でnode型を参照しようとするとコンパイルエラーが起きる
  - typedef struct nodeで回避
  - フィールドもstruct nodeと宣言
- nodeを使って連結リストを表現する
  - node *list
  - 最初のノードへのポインタを代入する
  - 変数を宣言しただけでは特に何も起こらない
  - ノードがないときはNULLで初期化しておくとよい
- 複雑なのでlinkedlist.cに書いている
  - 講義動画のものはlist_4.cに書いた
  - 要素を足す部分を関数やループにするのは演習で行うらしい
- 今日はここまで

## 0122(1:09:40~)
- forループでもメモリは開放できる
  - スタイルの問題でwhileを使った
  - forとwhileは相互に置き換えられる
- 連結リストをソートする時は注意が必要
  - 先頭から外れるとメモリの塊が迷子になる
  - 新たに挿入した要素「も」先頭を指すようにする→指す先を変える、でOK
  - 常に1つ以上の矢印で繋がっているように気をつける
- 連結リストの検索や挿入にかかる時間
  - 検索は先頭から1つ1つ確かめていく必要がある→O(n)
  - 挿入は条件による(リストはソートされているか・ソートを維持する必要はあるか)
  - ソートを維持する挿入はO(n)
  - 維持しない場合(先頭にどんどん足していく)はO(1)

### trees(1:23:30~)
- 連結リストが持つメモリ保持の楽さと、配列の検索しやすさを両立させたい
- 二分探索木
- すべてのノードが最大2つのポインタを持つ
  - どこからも指されないノードは「根/root」と呼ばれる
- node構造体にnextではなくleft/rightを持たせる
- 二分探索木はすべてのノードが0~2個のノードを持つ
  - 最大でも2個だから「二分」探索木
- 二分探索木の高さはlog_2 n(nはノードの数)
  - log_2とは、ある数を半分に割り続けて1になるまでの回数のこと
- メモリ量・時間・複雑性は常にトレードオフの関係にある
- 二分探索木を実装してみる
- tree.cがどこで配布されているかは不明
  - 画面で読み取れたものから実装した
- valgrindってどういう意味なんだろう
- バイナリサーチを実装する
- ここでようやくboolはstdbool.hにあると説明される
- 二分探索木は連結リストに近い構造を持つこともある
  - 定義として間違っていなければ、一部の連結リストも二分探索木と呼べる
  - AVL木・赤黒木と呼ぶこともある
  - 二分探索木だからといってバランスが取れているとは限らない
- バランスが取れた二分探索木の場合、検索にかかる計算量はO(log n)
  - バランスが取れていない場合はO(n)になるかもしれない
- バランスを取る方法は高度なのでここでは扱わない
  - 意図しない問題に発展する可能性は常に意識した方がよい

### hash tables(1:44:07)
- hash tableはよく使われている(データ構造のスイスアーミーナイフ)
- キーと値を関連付ける構造
- キー(ハッシュ)と連結リスト(同じキーを持つ要素)の組み合わせ
  - 連結リストを要素に持つ配列
  - 両方の長所を併せ持つ
- プログラムでhash tableを構築する
  - hashtables.c
- バケツの数と処理時間はトレードオフの関係にある
  - 中身のないバケツも増える
- ハッシュテーブルの検索も最悪の場合はO(n)になる
  - 格納したデータがほとんど同じハッシュを持つ場合は要素の連結リストを全部見る必要があるため
- 現実的には単一の連結リストより速くなる

### tries(1:57:25)
- 検索(retrieval)の略 トライと読む
- 巨大なデータセットでも一定時間で検索できるツリー構造
- 配列からツリーを作る
- 根が配列
  - それぞれの要素が別の要素＝配列を示す
- それぞれの要素はアルファベット26字の配列
  - 1文字ごとのインデックスを示すツリー構造
  - 最後の子は別の配列へのポインタではなくbool値などで終端を示す
- 途中まで同じ場合はノードを共有できる
- tries.c
- ツリーの高さは納めたい要素の文字数と等しい
  - 検索する時に必要なステップ数も文字数と等しい
  - 納められた要素の数には影響を受けない
  - つまり検索時間はO(1)
- 特定の文字列を含む文字列(DANIELとDANIELLE)も判別できる
  - 1つ目のLはis_wordがtrueかつchildrenを持つ
  - 終わるかもしれないし、続くかもしれない
- そしてやはり容量と時間はトレードオフの関係にある

### 抽象的なデータ構造(2:03:57)
- 配列・連結リスト・ツリー
- グラフ(あちこちにノードが繋がるリスト)
- キュー(FIFO構造)
  - enqueue(要素の追加)
  - dequeue(要素の取り出し)
  - キューのサイズを超えた場合の扱いに注意する必要がある
  - 連結リストを使うとサイズの問題は解決できる
- スタック(LIFO構造)
  - push(要素の追加)
  - pop(要素の取り出し)
- 辞書
  - ハッシュテーブルをさらに抽象化したもの
- 講義おわり！

## 0211
また時間が空いてしまった……

### lab5 問題文を読む
- alleles = 対立遺伝子(アレル/アリル)
- 世代の番号が直感とは逆方向なので戸惑う
  - 最も新しい世代＝0
  - 最も古い世代＝create_family関数の引数に渡された数-1
- TODOを見ると実装したくなるがまずは最後まで読むことに集中する
- とりあえず読み終えた
  - ウォークスルー動画は見ていない

### lab5 create_familyを実装する
- なんも覚えてない、まずい
- 手探りで頑張っている
- できたようなできないような
- 親の対立遺伝子から片方を選ぶ処理はselect_allele関数として独立させた
  - 宣言を先に書かなければならない制約が面倒
- allele「s」やparent「s」のsを忘れる
  - 今回のプロパティ名はどちらも複数形
  - makeコマンドのエラーメッセージが「もしかして」を表示してくれるので助かる
- makeはできたが表示処理がないのでまだ実行しても何も起こらないはず
  - セグフォが起きている……なぜ……
  - 一旦保留としてprint処理を実装する
- と思ったらprintは実装済なのか
  - ないのはfree_familyだった
- ということはcreate_familyでセグフォが起きたらしいのだが……まぁやはり終えてから考えよう

### lab5 free_familyを実装する
- print_familyを真似て実装した
- make問題なし
- やはりセグフォが起きている

### lab5 デバッグ
- セグフォが起きる箇所を特定する方法ってあるのかな
- ひとまずcreate_familyの中にブレークポイントを置いてデバッグ実行してみる
- select_alleleのreturnで例外が起きる
  - セグフォは思ったより広い範囲の例外を示しているらしい
- デバッグ実行中のparentsの中身がなんだかおかしかった
  - いくら遡っても配列が終わらない
  - 再帰の実行回数は正しかった
- そもそもparentsに生成物を代入していない気がする
  - しよう
- できたっぽい？
- 同じ関数を2回呼び出すところとか気になるけれどどうにもならなさそう
- check50も通った

### lab5 solution
- p->alleles[n] = p->parents[n]->alleles[rand()%2] でも対立遺伝子は代入できる
  - このあたりは好みの問題だろう
  - どっちでもよさそう
- なんとなく勘も戻ってきたのでこのまま演習へ

### pset 問題文を読む
- 今回の演習は1つだけ
- あらたな文法事項が急に増える
  - #define : コンパイル時に置き換える(今回はLENGTHを45へ置換)
- 英語が読めてよかったと痛感している
  - コメントを追えばなんとなく処理が分かる
- 「load、hash、size、check、unloadの順番に実装を完了する必要があります」とあるが宣言順は違う
  - 勝手にフォーマットされた？
  - check, hash, load, size, unloadの順
  - 試しにloadを先頭に持ってきてフォーマットし直したが順序は変わらなかった
  - 分かりづらいから指示に合わせておこう
- ハードコーディングされた一般的な単語ってなんだ
  - ともかく、dictionaryにない単語は、それがどんなに見慣れたものでもfalseとみなせばいいんだろうか
- それぞれの関数で実装すべき内容は何も説明されなかった……

### pset ウォークスルー動画
- 6つの動画は連続で再生される
- 自分が取り組む部分のコメントは日本語でも書いてあった方が安心できる
- load関数
  - 引数は「これから開こうとする辞書のファイル名」
- ハッシュテーブルってなんだったかなーとhashtables.cを開いたらなんか途中で切れている
  - 保存に失敗したのか、そもそも何も書かなかったのか
  - ハッシュテーブル＝連想配列を要素に持つ配列
  - hash関数はload関数の中から呼び出すのかな？
    - speller.cでは呼び出さないっぽいので多分合ってる
- Javaの感覚に慣れているとハッシュテーブルも連想配列も自分で用意しなければならないことに気付けない
  - そういえば連想配列(linkedlist)もなかったんだった
  - dictionary.cに要素として使う構造体(node)は用意されている
- これは動画を見ながら書いた方がいいかもしれない

### pset load関数
- ウォークスルーを見ながら手を動かす
- ファイル読み込みの方法を忘れた
  - 行ごとに区切るってどうやるんだっけ
  - 過去に書いたものも参考にしつつ進めるしかない
- 疲れてきた
- fscanfの使い方がいまいちわからないのでまた小さなサンプルを作る
  - fscanfsample.c
- なんか思ってたんと違う(無限ループが起きる)
- fscanfはファイルの終わりに到達するとEOFを返す
  - EOFは特殊な値らしい(NULLと同じように直接比較できる)
- 3つ目の引数に渡す配列の長さはLENGTH+1でいいんだろうか
  - 無駄が多い気がする
- だんだん動画字幕も難しい内容になってきた
- nodeは連想配列の先頭にどんどん足していくらしい
  - 新nodeのnextに現先頭nodeを入れてから先頭をすげ替える
- ハッシュ計算の方法は指定されなかった
  - このあたりに高速化の肝があるのだろう
  - 一旦は先頭文字を使うことにする
- 変数tableが言うことを聞いてくれない
  - dictionary.c:23:7: error: variable length array folded to constant array as an extension [-Werror,-Wgnu-folding-constant]
- やはり分からないので動画を見直すことにした
  - shortのhash tablesとか
- shortのhash tableで実装されているハッシュ関数
  - すべての文字のASCIICODE値を合計し、収める先の配列の要素数で割った余り
- short動画は概念の説明しかなかった
- と思ったら本編もほぼ概念的な話だった
  - hashtables.cはきちんと保存されていた
- 困ったなあ
- エラーメッセージで調べたところ、コンパイル時は定数Nがうまく置き換わらないらしい
  - https://stackoverflow.com/questions/18435302/variable-length-array-folded-to-constant-array
  - #defineで置き換えるなどの対処が必要？
  - 置き換えたらエラーは出なくなったが果たしてこれでいいんだろうか
- 夜も更けてきたので今日はここまで

## 0212

### pset tableの使い方/load関数
- そもそもポインタのあたりが今ひとつ分かっていないので復習する必要がある
  - どのへんで学んだ内容だったか……4週目？
- 4週目のノートを見直す
- &n：変数nのアドレスを取得する
- *&n：変数nのアドレスを取得し、そのアドレスに格納された値を参照する
- int *p：変数pにはポインタ(メモリ上の住所)を代入できる
  - Javaでいうところの参照型みたいなもの
  - つまりnode *table[N]はポインタを代入するための配列？
- tableの要素はポインタだから、要素を代入する変数もポインタとして宣言しなければならない
- 直したらmakeが通った
- 多分これでload関数は実装できたと思う

### pset hash関数
- 一応動画があったので見ておく
- よく考えると引数がchar *wordだから参照の仕方が間違っているかも？
- deterministic=決定論的
  - 同じ入力を与える限り常に同じ結果が得られること
- 具体的なハッシュアルゴリズムは説明されない
  - 工夫すべき場所だからかな
- ひとまずちゃんと動くかを小さなサンプルで検証する
  - 演習に使うファイルと混ぜたくないのでsampleディレクトリを作った
  - hash.cできちんと動くことを検証済
- ハッシュアルゴリズムは後で差し替えたい

### pset 試運転
- そもそも現時点でspellerは動かないんだろうか
  - 試しに↓を実行したら動くっぽいことが分かった
  - ./speller dictionaries/small texts/cat.txt
  - check関数が未実装なので結果は正しくない
- debug50 ./speller dictionaries/small texts/cat.txt
- 動きはするもののtablesには何も入っていない
- hash関数の戻り値が最小でも97(aのASCIICODE)なのでインデックスの外にある
  - それでも例外にならないの困る
- なｎ