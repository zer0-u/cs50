# week5 data structures

## 0118

- Codespaceそのものをアップデートすると自前で入れたプラグインが削除されてしまう
  - markdown all in oneを入れ直した

### mallocとrealloc
- C言語は今回で最後らしい
- 検索ではなく挿入コストの話
  - ソート済のサイズnの配列に要素を1つ挿入するには何ステップかかるか
  - O(n)・Ω(1)
- list[3]とmalloc()はメモリが確保される領域が違う
  - listはスタック
  - mallocはヒープ
  - このあたり覚えてないから復習しなければ
  - week4のnote見たら動画だった……
- list[3]だと永遠にサイズ3の配列を与えることになる
- list=tmpとする *前に* list(が指しているメモリの塊)を解放する必要がある
- コメントで書いた方が流れがわかりやすいかもしれない
- reallocは↓3つを行う
  - 新たなメモリの確保
  - 以前のメモリにあった内容を新たな領域にコピー
  - 以前のメモリを解放
- reallocの戻り値をもとの変数に代入することはできないんだろうか
  - 試してみたらできた(list_3_1.c)

### struct
- ドット演算子は構造の中のフィールドにアクセスする
- *は掛け算だったりポインタだったり間接参照だったりする
- structとドットと*があれば大抵のデータ構造は網羅できるらしい
- 糖衣構文「->」を使うとプロパティにアクセスして代入された値を見れる(. *と同義)
- 連結リスト(linked list)の話をしている
  - ポインタのための容量(8バイト)と引き換えにデータのコピーを免れる
  - 要素を作る時に、要素そのものを収める空間とは別にポインタを収める空間も要求する
- 連結リストの最後の要素はポインタとして何を持つべきか
  - 先頭の要素は無限ループを引き起こすので推奨できない
  - NULL(0x0)を入れる
- 循環を検出できれば＝先頭が判別できれば先頭の要素へのポインタも入れられる
- 今日はここまで

## 0119

### 36:00頃～
- mallocは有効なメモリを記録している
- コンパイラも有効/無効を区別する補助ができる
- 整数は4バイト、ポインタは8バイト
  - 単なる配列よりメモリは必要になる
  - コピー頻度とのトレードオフ

### ノード
- 連結リストの要素1つをノード(NODE)と呼ぶことにする
- structとtypedefを使ってノードを表現する
- フィールドは2つ
  - 要素そのもの(int number)
  - 次のノードへのポインタ(node *next)
  - nextは慣習的な名前
- node型の定義の中でnode型を参照しようとするとコンパイルエラーが起きる
  - typedef struct nodeで回避
  - フィールドもstruct nodeと宣言
- nodeを使って連結リストを表現する
  - node *list
  - 最初のノードへのポインタを代入する
  - 変数を宣言しただけでは特に何も起こらない
  - ノードがないときはNULLで初期化しておくとよい
- 複雑なのでlinkedlist.cに書いている
  - 講義動画のものはlist_4.cに書いた
  - 要素を足す部分を関数やループにするのは演習で行うらしい
- 今日はここまで

## 0122(1:09:40~)
- forループでもメモリは開放できる
  - スタイルの問題でwhileを使った
  - forとwhileは相互に置き換えられる
- 連結リストをソートする時は注意が必要
  - 先頭から外れるとメモリの塊が迷子になる
  - 新たに挿入した要素「も」先頭を指すようにする→指す先を変える、でOK
  - 常に1つ以上の矢印で繋がっているように気をつける
- 連結リストの検索や挿入にかかる時間
  - 検索は先頭から1つ1つ確かめていく必要がある→O(n)
  - 挿入は条件による(リストはソートされているか・ソートを維持する必要はあるか)
  - ソートを維持する挿入はO(n)
  - 維持しない場合(先頭にどんどん足していく)はO(1)

### trees(1:23:30~)
- 連結リストが持つメモリ保持の楽さと、配列の検索しやすさを両立させたい
- 二分探索木
- すべてのノードが最大2つのポインタを持つ
  - どこからも指されないノードは「根/root」と呼ばれる
- node構造体にnextではなくleft/rightを持たせる
- 二分探索木はすべてのノードが0~2個のノードを持つ
  - 最大でも2個だから「二分」探索木
- 二分探索木の高さはlog_2 n(nはノードの数)
  - log_2とは、ある数を半分に割り続けて1になるまでの回数のこと
- メモリ量・時間・複雑性は常にトレードオフの関係にある
- 二分探索木を実装してみる
- tree.cがどこで配布されているかは不明
  - 画面で読み取れたものから実装した
- valgrindってどういう意味なんだろう
- バイナリサーチを実装する
- ここでようやくboolはstdbool.hにあると説明される
- 二分探索木は連結リストに近い構造を持つこともある
  - 定義として間違っていなければ、一部の連結リストも二分探索木と呼べる
  - AVL木・赤黒木と呼ぶこともある
  - 二分探索木だからといってバランスが取れているとは限らない
- バランスが取れた二分探索木の場合、検索にかかる計算量はO(log n)
  - バランスが取れていない場合はO(n)になるかもしれない
- バランスを取る方法は高度なのでここでは扱わない
  - 意図しない問題に発展する可能性は常に意識した方がよい

### hash tables(1:44:07)
- hash tableはよく使われている(データ構造のスイスアーミーナイフ)
- キーと値を関連付ける構造
- キー(ハッシュ)と連結リスト(同じキーを持つ要素)の組み合わせ