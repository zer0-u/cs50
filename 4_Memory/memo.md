# 4 Memory

## 1225
- 記憶を失ったのでweek 3のNoteも見直した
    - https://cs50.jp/x/2021/week3/notes/
    - n log nとlog nの違いが分からないんだよな　定数倍ではないらしい
    - なんとなく思い出してきた
- google spreadsheetへのアクセス
    - cs50.ly/art
    - コピーしたもの　https://docs.google.com/spreadsheets/d/13dkNL613yYbEf8WoRXbdp7QEBYv6iwkLH2DfqyFoGIo/edit#gid=0
    - いわゆる「excel方眼紙」で何か描かれている訳ではなかった
- 英語字幕を出す方法がわからなくなった
    - 「自動翻訳」で日本語から英語に移すしかなくなっている？
- 16進数の話
    - なんで16進数を使うようになったんだっけ？
    - 1バイト＝8ビットで表せる数だからだった
    - なんで1バイトは8ビットになったんだろう
- 10進数と16進数を見分ける
    - 頭に0xとついていたら16進数
- 実行するごとに変数nのアドレスが変わる

## 0108

### mallocとfree
- 変数tに変数sの内容を代入してもsに代入されていたポインタが代入されるだけ＝代入した先の変更は変数sとtの両方に影響することは理解したが、t[0]=s[0]はポインタではなく要素の代入になるのはどうしてなんだろう？

### garbage.c
- 1:47:22頃
    - 初期化していない変数を参照するとどんな値が代入されるか分からない
    - 講義動画ではよくわからない数値(intの最大値に見える)が2つと0が1つ
    - 手元で実行した時は3つとも0だった
    - C言語ではデフォルトで何か代入されることはないからちゃんと初期値を代入しようね、という話だと理解

### mallocとfreeの続き
- Javaでいう基本データ型と参照型のように、変数に代入されているものが違うのだろうか？

### swap
- 変数名に*をつけると、変数に代入された値ではなくポインタが代入される
- *と&の使い方がごちゃごちゃになりそう

### scanf
- なんで""で文字列を表すことは決めていたのにstring型はないんだろう
    - 最小限の実装で済ませたかったから？
- char *sと宣言しただけでは「本来ならここにポインタ」があるだけなので、ポインタが指し示す先をmalloc等で用意する必要がある

### phonebook
- 実際のlabやproblem setにはない
    - 例示のためのプログラム？
- 講義動画おわり・今日はここまで

## 0110

### lab:volume
- そこまで難しいことはなさそう
- ファイル操作関係の関数は既に定義されている
- リファレンスサイトが見つからずちょっと探した
    - https://manual.cs50.io/
- fread関数の例を見てなんとなく理解した引数
    - 引数1：読み込むために必要な変数のアドレス
    - 引数2：カーソルそのものの大きさ
    - 引数3：カーソルが一度に動く量
    - 引数4：読み込むファイル
- fwriteも引数は同じらしい
- とりあえずヘッダのコピーだけ試してみる
    - segmentation faultだった
- 指示書きを下まで読んだらfread/fwriteの解説が載っていた
    - まずは最後まで読むべきだった

## 0111

### volume(header)
- 3つ目の引数の役目がわからない
- とりあえずfread関数の例にある通りwhile文を書いてみる
    - すごい量の数字が出てきた
- 頭から44番目までを切り取れば良いのか？
- wavファイルではなく中身がintのテキストファイルで試してみよう
    - freadsample.c
- ウォークスルーの動画が役に立った試しがない
    - 説明書きのほうが詳しい
    - オリジナルは動画しかないんだろうか
- テキストファイルでいろいろ試してみた
    - 2つ目の引数はカーソルの大きさ
    - 3つ目の引数はファイルに書き込まれた内容を区切る単位？
    - 両方sizeof(char)にしたら大丈夫だった
- volumeに戻る
    - uint8_tを1個分読み込むことに成功した
- これをHEADER_SIZE分繰り返せばいいのか？
- またテキストファイルで試してみる
    - 配列を作る意味がわかっていない
    - 読み込んだ端から書き出していけばいいのでは？
    - 同じfor文の中でfreadとfwriteを呼び出しても大丈夫そう
    - for文のインデックスでコピーする分量を制限できる
- volumeに引っ越す
- ヘッダーのコピーはできた気がする

### volume(body)
- ファイルの途中からコピーする必要がある
- 再びテキストファイルに戻る
- ヘッダのコピーで使ったfor文は、インデックスのiがループ終了条件の役割しか果たしていない
    - while文でも置き換えられる
    - 処理中にインデックスiが参照されない
- 途中から見るにはどうしたらいいんだろう？
-　ヘッダと本体でループを分けるのではなく、1つのループ処理の中で「ヘッダかそうでないか」を判断すべき？
    - テキストファイルバージョンで試したら行けそうな気がした
    - 書き込む前に処理を挟むことにも成功した
- forではなくwhileを使おうとするとインデックスとカーソルの2変数がスコープ外になるのでちょっと悲しい
- ヘッダはuint8_t, 本体はint16_tを使うから読み込み方法が違うことに気付いた
    - どうしよう
    - やっぱりループを分けて、本体コピー中は「ヘッダであれば何もしない」を挟む？
- uint8_tは1バイト(符号なし)、int16_tは2バイト(符号あり)、ヘッダは44バイト
- 「ヘッダであれば何もしない」を入れてみる
- それにしてもどうして説明には配列があるんだろう
- とりあえずそのままコピーはできたっぽい
- 後は音量を調整する
    - これはそこまで難しくなかった
    - 2倍程度だとあんまり差がわからないので10倍にしたら音が割れた
- あちこちでsizeofを呼び出しているので変数にまとめる
- 一応できたけどこれでいいかはちょっとわからない
    - 配列の謎はそのまま
- solution(動画)を見てみる
    - カーソルに配列を使うと、配列の要素の数だけ一括で読み込めるらしい
    - 模範解答は本体の読み込み時に「ヘッダー分を除く」的な処理を書いていない
    - ファイルを閉じるまでカーソルの位置は保持される……？
    - 3つ目の引数「1」は結局何を表しているんだろう
        - 2つ目の引数で表したサイズ「何個分」を読み込むかってことだろうか
- sample.cでカーソル位置について実験する
    - 維持されているーーーーーーー！！！！！！！
    - リファレンスにも書いてあった
    - The opened file “remembers” the number of bytes that were successfully read, such that subsequent calls to this function for stream will return bytes after those already read.
    - https://manual.cs50.io/3/fread
- とりあえずvolume.cからも「ヘッダー部分は無視する」処理を消した
- check50を実行してみる
    - うまくいかない
    - fread/fwriteの3つ目の引数をそれぞれ1にしてみたら配列を使わなくても通った
- 3つ目の引数の謎
    - 調べてみたところ "2つ目の引数で表したサイズ「何個分」を読み込むか" でいいらしい
    - 変な数を指定したのに動いたのはなんでなんだろ
    - sizeof(uint8_t)は1、sizeof(int16_t)は2を返す
    - 微妙に秒数が少なかったのはsizeof(int16_t)の影響かもしれない
    - 音の大きさはあんまり変わらない気がした
- 配列バージョンも作ってみたかったから、模範解答を書き写すvolume_solution.cを作った
    - 今までの演習にもsolutionあったのかな→あった。全然見てなかった
- 提出した！
- それぞれの週のlabにはsolutionがあるけど、probremにはないみたい

## 0114

### filter(less comfortable)
- 説明書きが複雑だしサンプルの実装済部分も読めない
    - 久しぶりの感覚
- 少なくとも「次の数行はイメージファイルを開き、それが実際にBMPファイルであることを確認」は前の段落で説明された「filtersの定義」よりずっと後の78行目あたりにある
- 実装済と思われるもの
    - 引数チェック
    - bmpファイルを読み込む
    - 引数のモードに応じてフィルタ処理用の関数を呼び出す
    - 変換後のbmpファイルを書き出す
- 実装済部分の説明は詳しいのにいきなり放り出されてびっくりしている
- 意味があるか謎だけどウォークスルー動画を見てみるか

### grayscale
- 初めてウォークスルー動画が役に立った
    - probrem setの翻訳はこの動画から抽出しているのかもしれない
    - 今回は長すぎて断念？
    - 自動生成でも英語字幕があれば問題なく理解できた
- 手順1 配列の要素からRGB値を得る
- 手順2 3つの値の平均を取る
- 手順3 平均値を新たなRGB値として配列に入れ直す
- 計算した値は0以上255以下の整数(integer)でなければならない
    - 小数部は最も近い整数に丸める
- やってみよう
- 計算して代入したが何も起こらない
- 配列の要素を変数に代入して「変数.プロパティ=新しい値」としても元の配列は変更されない
- このあたりのモデルが先週の講義からずっと混乱している気がする
- 「配列の要素.プロパティ=新しい値」なら問題なく更新される
- 平均が0未満になったり255を越えたりすることはないのでオーバーフローの考慮は不要
  - もともとの値が正しければ平均も範囲内に収まるはず
- この段階でcheck50をしてみる
  - 少なくともグレースケール周りはきちんと判断されるはず
  - 何かが間違っている
- 丸め処理が間違っているらしい
  - ただのint型計算だと切り捨てられる
  - round関数を使う(math.h)
  - Javaと同じく、計算結果の値は被演算子の型に影響されるので、どれか1つをdoubleにする必要がある
  - 今回は/3を/3.0とした
  - https://cs50.stackexchange.com/questions/35101/why-does-it-not-round-up-correctly
  - ここを見るのは大丈夫なんだろうか
- グレースケールのチェックは通った

### sepia
- グレースケールとほぼ同じ流れだろうとは思う
- 念のため再び動画を見る
  - 埋め込みだと謎のチカチカが発生した(再読み込みで直った)
- 変換式は与えられている
  - .393は0.393という意味
- こちらはオーバーフローが起きる可能性がある
  - 0未満にはならないが255は超えるかもしれない
  - adjust関数を用意して処理を切り出した
- ふと気づいたんだけども、C言語ってたくさん変数を用意するのはあまり推奨されていないのかな
- いい感じ
- round関数はmath.hのincludeが必須だった
  - check50は大丈夫だったのにmakeがこける
  - なぜ？
- check50は一発OKだった

### reflection
- 同じ列にある(=heightが同じ)ピクセルを入れ換える
- 真ん中は動かさない
- 内側(width)のループを半減させて入れ替えればよさそう？
- なんとなく実装してみる
- 出来た気がする
  - よく見比べないと反転している感がない
- 何一つとして合っていないらしい(check50全滅)
  - 正しそうに見えるんだけどな
- 対となるインデックス(変数opposite)の取り方が違うっぽい
  - 現在：width - w(ループインデックス)
  - widthは要素数だから、最大の添字より1大きい
- 最大の添字(変数max_index)からwを引くようにしたらチェックも通った
  - 画像が大きいと差が気にならないけどよく見るとズレてるのかな
- 変数max_indexはループ中変わらないので外側に出しておく

### blur
- 疲れてきた
- 自身を含む周辺9マスの平均値を新たにセットする
  - 画像からはみ出す場合は考慮しない
  - RGBそれぞれの平均を取る(グレースケールとは違う)
- 今思い浮かべている手順
  - 周辺9マスそれぞれについて、範囲内ならRGBそれぞれの値を足す
  - 足した値を範囲内のマスの数で割る(平均を求める)
  - 平均値を新たにセットする
- 周辺9マスとは
  - [h-1][w-1] / [h-1][w] / [h-1][w+1]
  - [h][w-1] / [h][w] / [h][w+1]
  - [h+1][w-1] / [h+1][w] / [h+1][w+1]
- 範囲内かどうか
  - 高さが0以上height-1以下 かつ 幅が0以上width-1以下
- ループが複雑になりそう
- ひとまず思いついたままに書いてみる
- h-1,h+1,w-1,w+1の4つがそれぞれ範囲内に収まっているかを確かめられればよさそう
- 判断する関数を切り出したいけど引数が増える
  - 判断したいペア＋判断基準のペアの4つが必要になる
  - しょうがないのかなー
- 関数は作ったけど呼び出し方に悩む
- 4重ループに手を出すしかないのか……？
- てか変数名キャメルケースでもいいのか
- ネストが～～～～深い～～～～！！！！！！！
- できたけども
- boolは型名じゃないって言われる
  - cs50.hをincludeしないといけないらしい
  - マジで？
- 外側のループをreflectionからコピーしたせいで半分ボケた画像ができた
  - 条件を直し忘れた
  - これはこれで違いがわかりやすい
- check50を実行する度にアクセストークンを求められるのはどうしたものかと思っている
  - 環境変数を見るようにできないかなぁ
- また何一つ合っていない
- check50の実行結果にURLがついてくることに気付いた
  - https://submit.cs50.io/check50/d4a658c48eb987c28223a2f2e23460e3aefffb2a
  - 少し詳しく見られる
  - でも想定値がどこを指しているかはよくわからない
  - 手計算で探した結果(127,140,149)は3×3の真ん中だと特定できた
  - これが(53,67,77)になってしまうらしい
- すごく テストコード ほしい
- 作るしかない
- include <>とinclude ""は何が違うんだろう
  - https://norizn.hatenablog.com/entry/2019/03/19/005835
  - ライブラリは<>、それ以外は""がいい？
  - ""を使うとカレントディレクトリから該当ファイルを検索するらしい
  - math.hとcs50.hはライブラリだから<>, helper.hはライブラリでないから""が妥当だと判断
  - makeできた
- image配列が自力で作れたら多分テストコードもいけるはず
- filter.cをコピーして作る
- makeも使えん　つらい
    - makefileの中身をコピーして若干変えた
    - コマンドをコピペして実行するのが一番手っ取り早かった
- あとは配列の中身を詰めるだけ
- 構造体の使い方を思い出している
- テストコードができた！！！！！！！(達成感すごい)
- テストコード(test.c)でdebug50をしてみたところ、内側のループが想定通りに動いていない感じがした
  - ループの境界値は+1ではなく+2では？
- 今更だけどmarkdownプラグイン入れた
- 手計算で期待値を割り出している
  - とても遠回りしている自覚はある
  - ズレに規則性が見えない
  - セルの中では一致しているような気がするが……
- さらに細かくデバッグ実行してみたところ、変更後の値が別のセルに影響していることが判明した
  - 座標(0,1)を変換する時に参照する座標(0,0)は変換[後]の値
  - どうしたものかな
- 引数として渡されたimageを複製して編集する必要がありそう
  - テストコードを作る時に見よう見まねでコピーした部分をさらに利用する
- だいぶ近くなってきた
  - あとは丸め処理を見直せばよさそう
  - countのdouble化(*1.0)をカッコでくくって割り算より先に計算されるようにした
  - 手計算の結果と揃った気がする
- 一応makeしてみる
  - 大丈夫そう
- できたーーーーーーーーーーーーーー！！！！！！！
- めちゃくちゃ効率悪い方法だろうことは分かるがこれ以上どうしたらいいかは分からない
- cs50.stackexchangeを見てみると、配列originalを宣言してもcallocは不要らしいと分かった
  - 実行もできたので該当部分を変更
- それ以外のもっと上手いやり方は分からない
  - こっそり調べたが多かれ少なかれみんな同じことをしている
  - floatでも++が使えるとわかったくらい……？
- 埒が明かないのでこれで提出した

### filter(more comfortable)
- ちらりと覗いてみた
- 基本的な構造は同じで、edgeという関数を追加するらしい
- そもそもの説明がなんも理解できない
  - 加重合計ってなんだっけ……？
  - 数学の知識が足りない
- ひとまず今日はここまで

## 0115

filter(more comfortable)は構造的にほぼ同じだと思うので一旦飛ばすことにした

### recover
- いきなり難しくなった
- 用意されたコードもほぼ空っぽ
- 動画を見よう
- 動画で示された手順
  - 1 メモリーカード(rawファイル)を開く
  - 2 JPEGファイルの開始地点を探す
  - 3 (見つかったら)新しいJPEGファイルを開く
  - 4 新たなJPEGファイルが見つかるまで、手順3で開いたファイルに512バイトずつ書き込む
  - 5 rawファイルが終了するで手順2～4を繰り返す
- カメラは512バイトを1つの塊として扱うので、JPEGのヘッダーチェックは512バイトごとで大丈夫
- fread(data,size,number,inptr)
  - data: pointer to where to store data you're reading
  - size: size of each element to read
  - number: number of elements to read
  - inptr: FILE * to read from
  - Returns number of items of size "size" were read
- 読み込んだ512バイトがJPEGかどうかを調べる
  - buffer[0]==0xffのように調べる
  - buffer[3]は少し工夫が必要
  - (buffer[3] & 0xf0) == 0xe0 (bitwise演算)
- ファイル名は3桁の連番.jpg
  - sprintf(filename, "%03i.jpg", 2)
  - filenameは恐らく番号そのもの
  - 2つ目の引数でフォーマットを行う
- fwrite(data,size,number,outptr)
- Pseudocode
  - open memory card
  - repeat until end of card:
    - read 512 bytes into a buffer
    - if start of new JPEG
      - ...
    - else
      - if already found jpeg
        - do nothing(keep writing current jpeg)
  - close any remaining files

### 引数チェック・fopen
- まずはrawファイルを開くところを実装する
- 配列の要素の型が分からない
  - filterのサンプルを漁ったらuint8_tをBYTE型として宣言していた
  - 恐らくこれを真似ればよさそう(符号なしでいいのかな？)
- なぜかセミコロンがないと怒られている
  - uint8_tの配列を宣言するとセミコロンがないと怒られる
  - uint8_tを使うにはstdintのincludeが必要だった
  - help50でも見つからないし分からなさすぎる

### ヘッダチェック
- if (block[0] == 0xff)でも問題なく分岐できた
  - 255が相当するらしい
- 条件が複雑なので関数に切り分ける
- またboolに引っかかった
  - 0以外が真、0が偽と捉えられているらしい
  - stdboolをincludeすると良い？(昔はbool型がないので独自で宣言したりしたらしい)
  - なんでこんな単純な型がなかったんだろう
- 配列blockは1個だけで大丈夫なのか不安だったけど、多分1ブロック読み込むごとにリセット？されているらしいので一旦よしとする

### 書き込み
- まずは正しいファイル名が出せるかどうか
- sprintfの1個目の引数はchar *でなければならないらしい(help50情報)
  - int型をそのまま渡すことはできない
  - なんか変換する関数があった気がするのでリファレンスを見に行く
  - atoiはstringからintに変えるやつだった
- sprintfについてもう少し調べてみた
  - https://monozukuri-c.com/langc-funclist-sprintf/
  - printfのように直接出力するわけではなく、フォーマット後の文字列を第1引数のポインタに代入するらしい
  - だから第1引数はchar *でなければならない
- 連番3桁＋.jpg(4文字)＋null文字の8桁必要
  - なんで突然配列になるかわからないしstringで覆ってもいいかもしれない
  - char filename[8]で動いたので保留
- 既にファイルが開いているかどうかで更に分岐が必要
  - filenumを-1から始めてインクリメントを先に行うようにすると、filenumで分岐が効かせられるはず
  - ↑違う気がする
  - 大人しく変数を1個増やそうと思う
- 説明の「デジタルカメラは写真をメモリカードに連続して保存する傾向があり、各写真は前に撮影された写真の直後に保存されます」はどの程度信頼できるのか
  - JPEGデータ/無関係な何か/JPEGデータのパターンは考慮しなくてもいい？
- ループ時の挙動はともかく、まずは1つ出力できるようになろう
  - 1枚出力したらbreakでループを抜ける
- なんかいろいろと条件を混同していることが分かってきた
  - ブロックがJPEGヘッダで始まるかどうかと、書き込み処理が行われているかは別の事象
- 条件を整理する
  - A ブロックがJPEGヘッダで始まる
    - A-1 ファイルに書き込んでいる：現在のファイルを閉じる・新しいファイルを開く
    - A-2 ファイルに書き込んでいない：新しいファイルを開く
  - B ブロックがJPEGヘッダで始まらない
    - B-1 ファイルに書き込んでいる：引き続き書き込む
    - B-2 ファイルに書き込んでいない：何もしない
- printfを使ってそれぞれの条件を整理してみた
  - 一度ファイルの書き出しが始まる=Aを通るとその後B-2は起こらないことが分かった
  - filenumを使って分岐を整理した
- 書き込み用のファイルを示す変数をどこで保持するかが問題
  - ループの外側でなんとなく維持はできるっぽいと分かった
  - でもうまく書き込めていない
- 生成されたファイルを消す手順が面倒
  - スクリプトファイル作った
  - chmod +x ファイル名 で実行権限付与
- 分岐は合っているはずだがなぜかうまく出力できない
- jpgファイルが開けない
  - 一応なんかそれっぽい値は入力されているようだが……
  - 何が駄目なのかわからないな
  - ヘッダを書き込んでいないからでは
- 条件を見直すとたしかにAの時に書き込む想定でなかった
- Bの分岐を独立させる→画像が出てきた！